# E2E 암호화 설계 명세 (E2E Encryption Design Specification)

이 문서는 Selah에 구현된 제로 지식(Zero-Knowledge) 종단간 암호화(End-to-End Encryption, E2E) 아키텍처의 상세 설계를 다룹니다.

## 설계 목표

1. **개인정보 보호**: 민감한 기도 데이터는 서버에서 평문으로 절대 접근할 수 없습니다.
2. **사용성**: 암호화를 위해 별도의 로그인 비밀번호를 요구하지 않고도 OAuth 로그인을 지원합니다.
3. **보안성**: 서버 데이터베이스가 침해되더라도 오프라인 브루트포스(Brute-force) 공격으로부터 데이터를 보호합니다.
4. **멀티 기기 지원**: 사용자가 6자리 PIN만으로 여러 기기에서 암호화된 데이터에 접근할 수 있도록 합니다.

---

## 핵심 아키텍처

### 1. 인증과 암호화의 분리

Selah는 기존의 E2E 시스템이 로그인 비밀번호에서 키를 유도하던 방식과 달리, 두 과정을 분리했습니다.

- **인증(Authentication)**: 이메일/비밀번호 또는 OAuth (Google, Apple, 카카오).
- **암호화(Encryption)**: 전용 6자리 PIN과 서버측 보조 키(Server Key).

이러한 분리를 통해 소셜 로그인의 편의성을 유지하면서도 강력한 E2E 암호화를 제공합니다.

### 2. 키 계층 구조 (Key Hierarchy)

| 키 이름                          | 설명                                                    |
|-------------------------------|-------------------------------------------------------|
| **DEK** (Data Encryption Key) | 실제 기도 데이터를 암호화하는 데 사용되는 랜덤 256비트 AES 키입니다.            |
| **Client KEK**                | 사용자의 6자리 PIN과 고유한 Salt를 결합하여 PBKDF2 알고리즘으로 유도된 키입니다.  |
| **Server Key**                | 사용자별로 서버에서 생성된 고유한 랜덤 키입니다.                           |
| **Combined KEK**              | Client KEK와 Server Key를 HKDF 알고리즘으로 결합하여 생성된 최종 키입니다. |

### 3. 암호화 계층 다이어그램

```
┌─────────────────────────────────────────────────────────────┐
│                      Encryption Hierarchy                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   [6-digit PIN] + [Salt]                                    │
│         │                                                   │
│         ▼ PBKDF2 (Client-side)                              │
│   [Client KEK] ──────┐                                      │
│                      │                                      │
│   [Server Key] ──────┼──▶ HKDF ──▶ [Combined KEK]           │
│   (From Server)      │              │                       │
│                                     ▼                       │
│                            AES-256-GCM Encryption           │
│                                     │                       │
│                              [Encrypted DEK]                │
│                              (Stored on Server)             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 상세 동작 플로우

### 설정 (최초 1회)

1. 클라이언트가 랜덤한 **DEK**를 생성합니다.
2. 사용자가 **6자리 PIN**을 설정합니다.
3. 클라이언트는 PIN과 랜덤 **Salt**를 사용하여 **Client KEK**를 유도합니다.
4. 서버는 **Server Key**를 생성하여 마스터 키로 암호화한 후 저장합니다.
5. 클라이언트는 서버로부터 **Server Key**를 받아 **Client KEK**와 결합하여 **Combined KEK**를 생성합니다.
6. 클라이언트는 **Combined KEK**로 **DEK**를 암호화하여 서버로 전송합니다.
7. 비상 시 접근을 위한 **복구 키(Recovery Key)**가 생성되어 사용자에게 표시됩니다.

### 데이터 저장

- **암호화 대상**: `PrayerTopic.title`, `PrayerTopic.reflection`, `Prayer.content`.
- **알고리즘**: AES-256-GCM.
- **프로세스**: 모든 평문 데이터는 API 서버로 전송되기 전 클라이언트에서 **DEK**로 암호화됩니다. 서버는 Base64로 인코딩된 암호문만 수신하고 저장합니다.

### 잠금 해제 (새 기기 또는 세션)

1. 사용자가 OAuth 또는 이메일로 로그인합니다.
2. **6자리 PIN** 입력 화면이 표시됩니다.
3. 클라이언트는 서버로부터 **Salt**, **Server Key**, **암호화된 DEK**를 가져옵니다.
4. 클라이언트는 **Combined KEK**를 유도하여 **DEK**를 복호화합니다.
5. 복호화된 **DEK**는 세션 동안 안전한 브라우저 저장소(IndexedDB)에 캐싱되어 반복적인 PIN 입력을 방지합니다.

---

## 보안 분석

### 왜 Server Key를 사용하는가?

6자리 PIN은 1,000,000가지의 조합만 가능하므로, 만약 Salt와 암호화된 DEK만 저장한다면 오프라인 브루트포스 공격에 취약합니다. Selah는 서버에 별도로 저장되고 암호화되어 관리되는 **Server
Key**를 요구함으로써 이를 보완합니다.

- 데이터베이스가 유출되더라도, 공격자는 **Server Key** 없이는 PIN을 무작위로 대입해볼 수 없습니다.
- 서버가 해킹당하더라도, 공격자는 사용자의 **PIN** 없이는 데이터를 복호화할 수 없습니다.

### 제로 지식 (Zero-Knowledge)

서버는 사용자의 PIN이나 평문 상태의 DEK를 **절대** 알 수 없습니다. 평문 데이터와 관련된 모든 암호화 작업은 사용자의 브라우저 내에서 Web Crypto API를 통해 엄격하게 수행됩니다.

---

## 복구 메커니즘

사용자가 PIN을 분실한 경우 **복구 키(Recovery Key)**를 사용할 수 있습니다. 복구 키는 높은 엔트로피를 가진 문자열로, DEK를 직접 복호화할 수 있어 사용자가 PIN을 재설정하고 새로운 키 계층을 생성할 수 있게 도와줍니다.

---

## 설계 배경 및 근거 (Design Rationale)

Selah가 현재의 하이브리드(PIN + Server Key) 방식을 선택한 이유는 다음과 같습니다.

1.  **보안과 편의성의 균형**: 일반적인 E2E 서비스는 매우 길고 복잡한 '마스터 비밀번호'를 요구하지만, 이는 사용자 경험(UX)을 저해하고 비밀번호 분실 위험을 높입니다. 6자리 PIN과 서버 보조 키를 결합함으로써, 사용자는 기억하기 쉬운 PIN을 사용하면서도 서버 측 보호를 통해 강력한 보안 수준을 유지할 수 있습니다.
2.  **현대적인 인증 방식 지원**: 많은 사용자가 소셜 로그인(OAuth)의 편리함을 기대합니다. 인증과 암호화 키 파생 로직을 완전히 분리함으로써, 사용자가 이메일로 가입하든 소셜 계정으로 로그인하든 차별 없는 암호화 경험을 제공할 수 있도록 설계했습니다.

---

## 고려 사항 및 한계점 (Considerations & Limitations)

### 1. 데이터 복구의 불가능성 (No Administrative Recovery)
Selah는 제로 지식 원칙을 준수하므로, 사용자가 **6자리 PIN과 복구 키를 모두 분실한 경우 서버에서도 데이터를 절대 복구할 수 없습니다.** 이는 데이터에 대한 완전한 통제권이 사용자에게 있음을 보장하기 위한 의도된 제약입니다.

### 2. 서버 가용성에 대한 의존성 (Server Availability)
오프라인 브루트포스 공격을 방지하기 위해 **Server Key**를 도입했기 때문에, 데이터를 복호화하려면 반드시 서버와 통신해야 합니다. 서버가 오프라인 상태이거나 Server Key가 손실될 경우, 사용자는 PIN을 알고 있더라도 데이터를 복호화할 수 없습니다. 따라서 서버 측 키 데이터베이스의 안정적인 관리와 백업은 시스템의 가용성을 유지하기 위한 핵심적인 운영 과제입니다.

### 3. 서버 측 기능의 제한 (Limited Server-side Features)
데이터가 암호문 상태로 저장되므로, 서버 측에서의 전체 텍스트 검색(Full-text search)이나 AI 분석 기능은 제공될 수 없습니다. 모든 데이터 가공 및 분석 작업은 클라이언트 측에서만 수행됩니다.
